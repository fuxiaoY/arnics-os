// .h file
#include "../../arnics-os/drivers/bsp/bsp_def.h"

/* USER CODE END Prototypes */
extern int bsp_tim_init(tim_t *dev);
extern int bsp_tim_close(tim_t *dev);
extern void bsp_tim_irq(tim_t *dev);


// .c file
/**
 * @brief 根据目标周期自动计算定时器参数
 * @param dev 定时器设备结构体指针
 * @return 0: 成功, -1: 失败
 */
static int bsp_tim_calculate_period(tim_t *dev)
{
    // 获取定时器时钟频率
    uint32_t timer_clock = HAL_RCC_GetPCLK1Freq();
    
    // 如果是高级定时器或通用定时器，需要考虑预分频情况
    // 对于STM32L4系列，TIM2-7, TIM12-14在APB1上
    // TIM1, TIM8, TIM15-17在APB2上
    
    // 计算需要的计数次数
    uint32_t total_counts = (uint32_t)(dev->period * timer_clock);
    
    // 如果计数次数小于等于0xFFFF，可以直接使用
    if (total_counts <= 0xFFFF) 
    {
        dev->htim.Init.Prescaler = 0;  // 不分频
        dev->htim.Init.Period = total_counts - 1;
    } 
    // 如果计数次数大于0xFFFF，需要使用预分频
    else 
    {
        uint32_t prescaler = (total_counts - 1) / 0xFFFF;
        if (prescaler > 0xFFFF) 
        {
            // 超出范围，无法设置
            return -1;
        }
        dev->htim.Init.Prescaler = prescaler;
        dev->htim.Init.Period = (total_counts / (prescaler + 1)) - 1;
    }
    return 0;
}


int bsp_tim_init(tim_t *dev)
{
  if(0 != bsp_tim_calculate_period(dev))
  {
    return -1;
  }
  if (HAL_TIM_Base_Init(&dev->htim) != HAL_OK)
  {
    Error_Handler();
    return -1;
  }
  if (HAL_TIM_ConfigClockSource(&dev->htim, &dev->sClockSourceConfig) != HAL_OK)
  {
    Error_Handler();
    return -2;
  }
  if (HAL_TIMEx_MasterConfigSynchronization(&dev->htim, &dev->sMasterConfig) != HAL_OK)
  {
    Error_Handler();
    return -3;
  }

  // 启用 TIM 的更新中断
  if (HAL_TIM_Base_Start_IT(&dev->htim) != HAL_OK)
  {
    Error_Handler();
    return -4;
  }
  return 0;
}
int bsp_tim_close(tim_t *dev)
{
  if (HAL_TIM_Base_DeInit(&dev->htim) != HAL_OK)
  {
    Error_Handler();
    return -1;
  }
  else
  {
    return 0;
  }
}

void bsp_tim_irq(tim_t *dev)
{
  HAL_TIM_IRQHandler(&dev->htim);
}



